{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"ONBOARDING/","text":"Onboarding & Compatibility Policy Onboarding Guide Welcome to the Hybrid Compute project. This guide introduces the architecture, workflow, and platform requirements for contributors and users. For New Contributors 1. Development Environment Setup Follow the setup instructions in README.md based on your platform (macOS, Linux, or Windows). 2. Architecture Overview Hybrid Compute consists of: Local CPU Processing : Image tiling and stitching using C/C++ with OpenCV or stb_image GPU Acceleration : CUDA (Linux/Windows) or Metal (macOS) for upscaling operations Python Orchestration : Pipeline coordination and testing 3. Development Workflow Fork and clone the repository Create a feature branch from main Implement changes following the commit standards Run the full test suite ( ./scripts/run.sh ) Open a pull request with a clear description 4. Important Files CMakeLists.txt : Build configuration src/preprocess.c : CPU image preprocessing cloud_gpu/upscale.cu : CUDA upscaling src/metal/Upscale.metal : Metal shader implementation scripts/e2e.py : End-to-end testing logic 5. Testing Requirements All changes must pass: Unit tests ( ctest ) Integration tests ( pytest ) Cross-platform builds (macOS, Linux, Windows) Docker-based isolation tests For Users Quick Start ./scripts/setup.sh ./scripts/run.sh Troubleshooting Build issues : Refer to DEVELOPMENT.md GPU issues : Validate CUDA/Metal driver installation Performance concerns : Run benchmarks to verify acceleration Compatibility Policy Supported Platforms Platform Architecture GPU Support Status macOS 11.0+ x86_64, ARM64 Metal Active Ubuntu 20.04+ x86_64 CUDA 11.8+ Active Windows 10+ x86_64 CUDA 11.8+ Active Language Versions C/C++: C17 / C++20 CUDA: 11.8+ Metal: macOS 11.0+ Python: 3.9+ Dependencies Required CMake 3.10+ CUDA Toolkit 11.8+ (for GPU builds) OpenCV 4.x (optional; stb_image is the fallback) Optional Google Benchmark (performance testing) OpenMP (parallel CPU processing) Compatibility Guarantees API Stability Major (X.0.0): Breaking changes allowed Minor (x.Y.0): Backward-compatible feature additions Patch (x.y.Z): Bug fixes only Platform Support Levels Active : Fully tested in CI Deprecated : Functional but untested Removed : No longer supported GPU Compatibility CUDA: NVIDIA GPUs supporting CUDA 11.8+ Metal: Apple Silicon and Intel-based macOS 11.0+ hardware Breaking Changes Policy Breaking changes will: Be documented in release notes Include deprecation warnings when possible Provide at least one minor version notice before removal Testing Compatibility Compatibility is validated across: Multiple OS versions Diverse GPU configurations CPU fallback modes Containerized environments Support Timeline Bug fixes: 2 years after initial release Security updates: 3 years Platform support: Maintained as long as the vendor supports the platform Proposing Compatibility Changes Contributors must: Update this document Adjust CI matrices Update dependency constraints Validate changes across all supported systems For questions about onboarding or compatibility, open an issue or discussion on GitHub.","title":"Onboarding &amp; Compatibility Policy"},{"location":"ONBOARDING/#onboarding-compatibility-policy","text":"","title":"Onboarding &amp; Compatibility Policy"},{"location":"ONBOARDING/#onboarding-guide","text":"Welcome to the Hybrid Compute project. This guide introduces the architecture, workflow, and platform requirements for contributors and users.","title":"Onboarding Guide"},{"location":"ONBOARDING/#for-new-contributors","text":"","title":"For New Contributors"},{"location":"ONBOARDING/#1-development-environment-setup","text":"Follow the setup instructions in README.md based on your platform (macOS, Linux, or Windows).","title":"1. Development Environment Setup"},{"location":"ONBOARDING/#2-architecture-overview","text":"Hybrid Compute consists of: Local CPU Processing : Image tiling and stitching using C/C++ with OpenCV or stb_image GPU Acceleration : CUDA (Linux/Windows) or Metal (macOS) for upscaling operations Python Orchestration : Pipeline coordination and testing","title":"2. Architecture Overview"},{"location":"ONBOARDING/#3-development-workflow","text":"Fork and clone the repository Create a feature branch from main Implement changes following the commit standards Run the full test suite ( ./scripts/run.sh ) Open a pull request with a clear description","title":"3. Development Workflow"},{"location":"ONBOARDING/#4-important-files","text":"CMakeLists.txt : Build configuration src/preprocess.c : CPU image preprocessing cloud_gpu/upscale.cu : CUDA upscaling src/metal/Upscale.metal : Metal shader implementation scripts/e2e.py : End-to-end testing logic","title":"4. Important Files"},{"location":"ONBOARDING/#5-testing-requirements","text":"All changes must pass: Unit tests ( ctest ) Integration tests ( pytest ) Cross-platform builds (macOS, Linux, Windows) Docker-based isolation tests","title":"5. Testing Requirements"},{"location":"ONBOARDING/#for-users","text":"","title":"For Users"},{"location":"ONBOARDING/#quick-start","text":"./scripts/setup.sh ./scripts/run.sh","title":"Quick Start"},{"location":"ONBOARDING/#troubleshooting","text":"Build issues : Refer to DEVELOPMENT.md GPU issues : Validate CUDA/Metal driver installation Performance concerns : Run benchmarks to verify acceleration","title":"Troubleshooting"},{"location":"ONBOARDING/#compatibility-policy","text":"","title":"Compatibility Policy"},{"location":"ONBOARDING/#supported-platforms","text":"Platform Architecture GPU Support Status macOS 11.0+ x86_64, ARM64 Metal Active Ubuntu 20.04+ x86_64 CUDA 11.8+ Active Windows 10+ x86_64 CUDA 11.8+ Active","title":"Supported Platforms"},{"location":"ONBOARDING/#language-versions","text":"C/C++: C17 / C++20 CUDA: 11.8+ Metal: macOS 11.0+ Python: 3.9+","title":"Language Versions"},{"location":"ONBOARDING/#dependencies","text":"","title":"Dependencies"},{"location":"ONBOARDING/#required","text":"CMake 3.10+ CUDA Toolkit 11.8+ (for GPU builds) OpenCV 4.x (optional; stb_image is the fallback)","title":"Required"},{"location":"ONBOARDING/#optional","text":"Google Benchmark (performance testing) OpenMP (parallel CPU processing)","title":"Optional"},{"location":"ONBOARDING/#compatibility-guarantees","text":"","title":"Compatibility Guarantees"},{"location":"ONBOARDING/#api-stability","text":"Major (X.0.0): Breaking changes allowed Minor (x.Y.0): Backward-compatible feature additions Patch (x.y.Z): Bug fixes only","title":"API Stability"},{"location":"ONBOARDING/#platform-support-levels","text":"Active : Fully tested in CI Deprecated : Functional but untested Removed : No longer supported","title":"Platform Support Levels"},{"location":"ONBOARDING/#gpu-compatibility","text":"CUDA: NVIDIA GPUs supporting CUDA 11.8+ Metal: Apple Silicon and Intel-based macOS 11.0+ hardware","title":"GPU Compatibility"},{"location":"ONBOARDING/#breaking-changes-policy","text":"Breaking changes will: Be documented in release notes Include deprecation warnings when possible Provide at least one minor version notice before removal","title":"Breaking Changes Policy"},{"location":"ONBOARDING/#testing-compatibility","text":"Compatibility is validated across: Multiple OS versions Diverse GPU configurations CPU fallback modes Containerized environments","title":"Testing Compatibility"},{"location":"ONBOARDING/#support-timeline","text":"Bug fixes: 2 years after initial release Security updates: 3 years Platform support: Maintained as long as the vendor supports the platform","title":"Support Timeline"},{"location":"ONBOARDING/#proposing-compatibility-changes","text":"Contributors must: Update this document Adjust CI matrices Update dependency constraints Validate changes across all supported systems For questions about onboarding or compatibility, open an issue or discussion on GitHub.","title":"Proposing Compatibility Changes"},{"location":"TESTING/","text":"Testing and Benchmarking Guide This document provides information on how to run tests and benchmarks for the Metal shim implementation. Prerequisites Xcode command line tools CMake 3.10+ C++17 compatible compiler Metal-capable macOS device Code Quality Before running tests, ensure code quality standards are met using pre-commit hooks: pre-commit run --all-files Quality Checks Overview Check GitHub Actions CircleCI Tools Code Formatting \u2713 \u2713 Black, isort Linting \u2713 \u2713 Ruff YAML Validation \u2713 \u2713 yamllint File Checks \u2713 \u2713 pre-commit-hooks Security Analysis \u2713 \u2713 CodeQL Container Scanning \u2713 \u2713 Trivy Commit Messages \u2713 \u2713 commit-msg hook Running Tests Unit Tests To build and run the unit tests: mkdir -p build && cd build cmake .. -DBUILD_TESTS=ON make ctest --output-on-failure Performance Benchmarks To run the performance benchmarks: cd build ./bin/benchmark_metal_shim --benchmark_min_time=1s Running Individual Benchmarks Locally For manual testing or debugging: # Build first mkdir build && cd build cmake .. -DCMAKE_BUILD_TYPE=Release # On Linux: make -j$(nproc) # On macOS: make -j$(sysctl -n hw.ncpu) # Run benchmark library tests (e.g., user counters) ./bin/user_counters_tabular_test --benchmark_min_time=1s --benchmark_repetitions=3 # Run project performance benchmarks (Metal shim) ./bin/benchmark_metal_shim Test Coverage To generate a test coverage report (requires gcov and lcov ): mkdir -p build_coverage && cd build_coverage cmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON make test_metal_shim lcov --capture --directory . --output-file coverage.info genhtml coverage.info --output-directory coverage open coverage/index.html Writing Tests Unit Tests Place unit tests in tests/unit/ Use Google Test framework Test files should be named test_*.cpp Test cases should be small and focused Benchmark Tests Place benchmark tests in tests/performance/ Use Google Benchmark framework Test files should be named benchmark_*.cpp Include a range of input sizes CI/CD Integration Tests are automatically run on pull requests and pushes to the main branch. The CI pipeline includes comprehensive quality checks: CI Pipeline Components Build verification across platforms (Linux, macOS, Windows) Unit tests with multiple Python versions Code style checks and formatting validation Security vulnerability scanning Performance benchmarking Docker container builds and testing Automated documentation generation Performance Profiling To profile the Metal shim: Use Xcode's Instruments Select the Time Profiler Run your benchmark or test Analyze the results Memory Management Use the following tools to check for memory issues: Xcode's Memory Graph Debugger Address Sanitizer (add -fsanitize=address to compiler flags) Leak Sanitizer (add -fsanitize=leak to compiler flags) Troubleshooting Test Executable Not Found If ctest reports \"Could not find executable\", build first: cmake --build build cd build && ctest -R user_counters_tabular_test -V Best Practices Write tests for all new features Update tests when modifying existing code Keep tests independent and isolated Use meaningful test names Include assertions for expected behavior Test edge cases and error conditions Document test assumptions and requirements","title":"Testing and Benchmarking Guide"},{"location":"TESTING/#testing-and-benchmarking-guide","text":"This document provides information on how to run tests and benchmarks for the Metal shim implementation.","title":"Testing and Benchmarking Guide"},{"location":"TESTING/#prerequisites","text":"Xcode command line tools CMake 3.10+ C++17 compatible compiler Metal-capable macOS device","title":"Prerequisites"},{"location":"TESTING/#code-quality","text":"Before running tests, ensure code quality standards are met using pre-commit hooks: pre-commit run --all-files","title":"Code Quality"},{"location":"TESTING/#quality-checks-overview","text":"Check GitHub Actions CircleCI Tools Code Formatting \u2713 \u2713 Black, isort Linting \u2713 \u2713 Ruff YAML Validation \u2713 \u2713 yamllint File Checks \u2713 \u2713 pre-commit-hooks Security Analysis \u2713 \u2713 CodeQL Container Scanning \u2713 \u2713 Trivy Commit Messages \u2713 \u2713 commit-msg hook","title":"Quality Checks Overview"},{"location":"TESTING/#running-tests","text":"","title":"Running Tests"},{"location":"TESTING/#unit-tests","text":"To build and run the unit tests: mkdir -p build && cd build cmake .. -DBUILD_TESTS=ON make ctest --output-on-failure","title":"Unit Tests"},{"location":"TESTING/#performance-benchmarks","text":"To run the performance benchmarks: cd build ./bin/benchmark_metal_shim --benchmark_min_time=1s","title":"Performance Benchmarks"},{"location":"TESTING/#running-individual-benchmarks-locally","text":"For manual testing or debugging: # Build first mkdir build && cd build cmake .. -DCMAKE_BUILD_TYPE=Release # On Linux: make -j$(nproc) # On macOS: make -j$(sysctl -n hw.ncpu) # Run benchmark library tests (e.g., user counters) ./bin/user_counters_tabular_test --benchmark_min_time=1s --benchmark_repetitions=3 # Run project performance benchmarks (Metal shim) ./bin/benchmark_metal_shim","title":"Running Individual Benchmarks Locally"},{"location":"TESTING/#test-coverage","text":"To generate a test coverage report (requires gcov and lcov ): mkdir -p build_coverage && cd build_coverage cmake .. -DCMAKE_BUILD_TYPE=Debug -DENABLE_COVERAGE=ON make test_metal_shim lcov --capture --directory . --output-file coverage.info genhtml coverage.info --output-directory coverage open coverage/index.html","title":"Test Coverage"},{"location":"TESTING/#writing-tests","text":"","title":"Writing Tests"},{"location":"TESTING/#unit-tests_1","text":"Place unit tests in tests/unit/ Use Google Test framework Test files should be named test_*.cpp Test cases should be small and focused","title":"Unit Tests"},{"location":"TESTING/#benchmark-tests","text":"Place benchmark tests in tests/performance/ Use Google Benchmark framework Test files should be named benchmark_*.cpp Include a range of input sizes","title":"Benchmark Tests"},{"location":"TESTING/#cicd-integration","text":"Tests are automatically run on pull requests and pushes to the main branch. The CI pipeline includes comprehensive quality checks:","title":"CI/CD Integration"},{"location":"TESTING/#ci-pipeline-components","text":"Build verification across platforms (Linux, macOS, Windows) Unit tests with multiple Python versions Code style checks and formatting validation Security vulnerability scanning Performance benchmarking Docker container builds and testing Automated documentation generation","title":"CI Pipeline Components"},{"location":"TESTING/#performance-profiling","text":"To profile the Metal shim: Use Xcode's Instruments Select the Time Profiler Run your benchmark or test Analyze the results","title":"Performance Profiling"},{"location":"TESTING/#memory-management","text":"Use the following tools to check for memory issues: Xcode's Memory Graph Debugger Address Sanitizer (add -fsanitize=address to compiler flags) Leak Sanitizer (add -fsanitize=leak to compiler flags)","title":"Memory Management"},{"location":"TESTING/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"TESTING/#test-executable-not-found","text":"If ctest reports \"Could not find executable\", build first: cmake --build build cd build && ctest -R user_counters_tabular_test -V","title":"Test Executable Not Found"},{"location":"TESTING/#best-practices","text":"Write tests for all new features Update tests when modifying existing code Keep tests independent and isolated Use meaningful test names Include assertions for expected behavior Test edge cases and error conditions Document test assumptions and requirements","title":"Best Practices"}]}